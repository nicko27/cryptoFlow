"""
Market Service - Gestion des donn√©es de march√© [TIMEZONE FIXED]
"""

from typing import List, Optional, Dict
from datetime import datetime, timedelta, timezone
from core.models import (
    MarketData, CryptoPrice, TechnicalIndicators,
    Prediction, PredictionType, OpportunityScore
)
from api.binance_api import BinanceAPI


class MarketService:
    """Service de gestion des donn√©es de march√©"""
    
    def __init__(self, binance_api: BinanceAPI):
        self.binance_api = binance_api
        self.market_cache: Dict[str, MarketData] = {}
        self.price_history_cache: Dict[str, List[CryptoPrice]] = {}
    
    def get_market_data(self, symbol: str, refresh: bool = True) -> Optional[MarketData]:
        """R√©cup√®re les donn√©es de march√© compl√®tes"""
        if not refresh and symbol in self.market_cache:
            cached = self.market_cache[symbol]
            age = (datetime.now(timezone.utc) - cached.current_price.timestamp).total_seconds()
            if age < 60:
                return cached
        
        current_price = self.binance_api.get_current_price(symbol)
        if not current_price:
            return None
        
        price_history = self.binance_api.get_price_history(symbol, interval="1m", limit=200)
        if symbol not in self.price_history_cache:
            self.price_history_cache[symbol] = []
        
        self.price_history_cache[symbol].append(current_price)
        self.price_history_cache[symbol] = self.price_history_cache[symbol][-1000:]
        
        all_prices = price_history + self.price_history_cache[symbol]
        technical_indicators = self.binance_api.calculate_technical_indicators(all_prices)
        
        funding_rate = self.binance_api.get_funding_rate(symbol)
        open_interest = self.binance_api.get_open_interest(symbol)
        fear_greed = self.binance_api.get_fear_greed_index()
        weekly_change = self.binance_api.get_price_change_percent(symbol, interval="1d", periods=7)

        price_change_24h = current_price.change_24h if current_price else None
        volume_24h = current_price.volume_24h if current_price else None

        market_data = MarketData(
            symbol=symbol,
            current_price=current_price,
            technical_indicators=technical_indicators,
            price_change_24h=price_change_24h,
            price_change_7d=weekly_change,
            volume_24h=volume_24h,
            funding_rate=funding_rate,
            open_interest=open_interest,
            fear_greed_index=fear_greed,
            price_history=all_prices[-200:],
            weekly_change=weekly_change
        )
        
        self.market_cache[symbol] = market_data
        return market_data
    
    def get_price_history(self, symbol: str, hours: int = 24) -> List[CryptoPrice]:
        """R√©cup√®re un historique couvrant la p√©riode demand√©e."""
        cutoff = datetime.now(timezone.utc) - timedelta(hours=hours)

        interval, limit = self._determine_interval(hours)

        cache = self.price_history_cache.get(symbol, [])
        need_fetch = True
        if cache:
            earliest = min(cache, key=lambda p: p.timestamp)
            recent_count = len([p for p in cache if p.timestamp >= cutoff])
            need_fetch = earliest.timestamp > cutoff or recent_count < 2

        if need_fetch:
            fresh = self.binance_api.get_price_history(symbol, interval=interval, limit=limit)
            if fresh:
                merged = {price.timestamp: price for price in cache}
                for price in fresh:
                    merged[price.timestamp] = price
                cache = sorted(merged.values(), key=lambda p: p.timestamp)
                self.price_history_cache[symbol] = cache[-3000:]
        else:
            self.price_history_cache[symbol] = cache

        filtered = [p for p in self.price_history_cache[symbol] if p.timestamp >= cutoff]

        if len(filtered) < 2:
            # Tentative suppl√©mentaire avec un intervalle plus large si insuffisant
            fallback_interval, fallback_limit = self._determine_interval(hours * 2)
            fresh = self.binance_api.get_price_history(symbol, interval=fallback_interval, limit=fallback_limit)
            if fresh:
                merged = {price.timestamp: price for price in self.price_history_cache.get(symbol, [])}
                for price in fresh:
                    merged[price.timestamp] = price
                self.price_history_cache[symbol] = sorted(merged.values(), key=lambda p: p.timestamp)[-3000:]
                filtered = [p for p in self.price_history_cache[symbol] if p.timestamp >= cutoff]

        return filtered

    @staticmethod
    def _determine_interval(hours: int) -> tuple:
        if hours <= 24:
            interval = "15m" if hours > 6 else "1m"
            limit = min(hours * (60 // (15 if interval == "15m" else 1)), 1000)
        elif hours <= 168:
            interval = "1h"
            limit = min(hours, 1000)
        else:
            interval = "4h"
            limit = min(max(hours // 4, 1), 1000)
        return interval, limit
    
    def calculate_price_change(self, symbol: str, minutes: int) -> float:
        """Calcule le changement de prix sur N minutes"""
        market_data = self.get_market_data(symbol, refresh=False)
        if not market_data:
            return 0.0
        
        return market_data.get_price_change(minutes)
    
    def get_extremes(self, symbol: str, hours: int = 168) -> Dict[str, float]:
        """Trouve les prix min/max/avg sur une p√©riode"""
        prices = self.get_price_history(symbol, hours)
        
        if not prices:
            return {"min": 0.0, "max": 0.0, "avg": 0.0}
        
        price_values = [p.price_eur for p in prices]
        
        return {
            "min": min(price_values),
            "max": max(price_values),
            "avg": sum(price_values) / len(price_values)
        }
    
    def predict_price_movement(self, market_data: MarketData) -> Prediction:
        """Pr√©dit le mouvement de prix"""
        ti = market_data.technical_indicators
        trend_score = 0
        signals = []
        
        # RSI
        if ti.rsi < 30:
            trend_score += 2
            signals.append("RSI survendu (rebond probable)")
        elif ti.rsi < 40:
            trend_score += 1
            signals.append("RSI bas (opportunit√©)")
        elif ti.rsi > 70:
            trend_score -= 2
            signals.append("RSI surachet√© (correction possible)")
        elif ti.rsi > 60:
            trend_score -= 1
            signals.append("RSI √©lev√© (prudence)")
        
        # MACD
        if ti.macd_histogram > 0:
            trend_score += 1
            signals.append("MACD positif")
        else:
            trend_score -= 1
            signals.append("MACD n√©gatif")
        
        # Moyennes mobiles
        current_price = market_data.current_price.price_eur
        if current_price > ti.ma20:
            trend_score += 1
            signals.append("Au-dessus MA20")
        elif current_price < ti.ma20:
            trend_score -= 1
            signals.append("En-dessous MA20")
        
        # Support/R√©sistance
        if ti.support > 0:
            distance_to_support = abs(current_price - ti.support) / current_price * 100
            if distance_to_support < 2:
                trend_score += 1
                signals.append("Proche du support")
        
        if ti.resistance > 0:
            distance_to_resistance = abs(ti.resistance - current_price) / current_price * 100
            if distance_to_resistance < 2:
                trend_score -= 1
                signals.append("Proche r√©sistance")
        
        # D√©terminer pr√©diction
        if trend_score >= 3:
            prediction_type = PredictionType.BULLISH
            direction = "üìà"
            confidence = min(85, 60 + trend_score * 5)
            target_high = ti.resistance if ti.resistance > 0 else current_price * 1.05
            target_low = current_price * 0.97
        elif trend_score >= 1:
            prediction_type = PredictionType.SLIGHTLY_BULLISH
            direction = "‚ÜóÔ∏è"
            confidence = 55 + trend_score * 5
            target_high = current_price * 1.03
            target_low = current_price * 0.98
        elif trend_score <= -3:
            prediction_type = PredictionType.BEARISH
            direction = "üìâ"
            confidence = min(85, 60 - trend_score * 5)
            target_low = ti.support if ti.support > 0 else current_price * 0.95
            target_high = current_price * 1.03
        elif trend_score <= -1:
            prediction_type = PredictionType.SLIGHTLY_BEARISH
            direction = "‚ÜòÔ∏è"
            confidence = 55 - trend_score * 5
            target_low = current_price * 0.97
            target_high = current_price * 1.02
        else:
            prediction_type = PredictionType.NEUTRAL
            direction = "‚û°Ô∏è"
            confidence = 50
            target_high = ti.resistance if ti.resistance > 0 else current_price * 1.05
            target_low = ti.support if ti.support > 0 else current_price * 0.95
        
        # Timeline
        if prediction_type in [PredictionType.BULLISH, PredictionType.SLIGHTLY_BULLISH]:
            short_mult = 1.005 if prediction_type == PredictionType.SLIGHTLY_BULLISH else 1.02
            medium_mult = 1.03 if prediction_type == PredictionType.SLIGHTLY_BULLISH else 1.06
            long_mult = 1.05 if prediction_type == PredictionType.SLIGHTLY_BULLISH else 1.10
        elif prediction_type in [PredictionType.BEARISH, PredictionType.SLIGHTLY_BEARISH]:
            short_mult = 0.995 if prediction_type == PredictionType.SLIGHTLY_BEARISH else 0.98
            medium_mult = 0.97 if prediction_type == PredictionType.SLIGHTLY_BEARISH else 0.95
            long_mult = 0.96 if prediction_type == PredictionType.SLIGHTLY_BEARISH else 0.92
        else:
            short_mult = 1.0
            medium_mult = 1.0
            long_mult = 1.0
        
        return Prediction(
            prediction_type=prediction_type,
            confidence=confidence,
            direction=direction,
            trend_score=trend_score,
            signals=signals,
            target_high=target_high,
            target_low=target_low,
            timeframe_short=current_price * short_mult,
            timeframe_medium=current_price * medium_mult,
            timeframe_long=current_price * long_mult
        )
    
    def calculate_opportunity_score(self, market_data: MarketData, prediction: Prediction) -> OpportunityScore:
        """Calcule le score d'opportunit√© d'achat (0-10)"""
        score = 5.0
        reasons = []
        
        # Pr√©diction
        if prediction.prediction_type == PredictionType.BULLISH:
            if prediction.confidence >= 75:
                score += 2
                reasons.append("‚úÖ Signal tr√®s haussier")
            else:
                score += 1
                reasons.append("‚úÖ Signal haussier")
        elif prediction.prediction_type == PredictionType.SLIGHTLY_BULLISH:
            score += 0.5
            reasons.append("‚úÖ Tendance l√©g√®rement positive")
        elif prediction.prediction_type == PredictionType.BEARISH:
            score -= 2
            reasons.append("‚ö†Ô∏è Signal baissier")
        elif prediction.prediction_type == PredictionType.SLIGHTLY_BEARISH:
            score -= 1
            reasons.append("‚ö†Ô∏è Tendance l√©g√®rement n√©gative")
        
        # RSI
        rsi = market_data.technical_indicators.rsi
        if rsi < 30:
            score += 2
            reasons.append("‚úÖ Prix tr√®s bas (survendu)")
        elif rsi < 40:
            score += 1
            reasons.append("‚úÖ Prix assez bas")
        elif rsi > 70:
            score -= 1.5
            reasons.append("‚ö†Ô∏è Prix tr√®s haut (surachet√©)")
        
        # Fear & Greed
        if market_data.fear_greed_index:
            fgi = market_data.fear_greed_index
            if fgi <= 25:
                score += 2
                reasons.append("‚úÖ March√© en peur extr√™me")
            elif fgi <= 40:
                score += 1
                reasons.append("‚úÖ March√© craintif")
            elif fgi >= 75:
                score -= 1.5
                reasons.append("‚ö†Ô∏è March√© tr√®s euphorique")
        
        # Changement 24h
        change_24h = market_data.current_price.change_24h
        if change_24h < -10:
            score += 1.5
            reasons.append(f"‚úÖ Forte baisse r√©cente ({change_24h:.1f}%)")
        elif change_24h < -5:
            score += 0.5
            reasons.append("‚úÖ Baisse r√©cente")
        elif change_24h > 15:
            score -= 1
            reasons.append("‚ö†Ô∏è Forte hausse r√©cente")
        
        # Position vs historique
        extremes = self.get_extremes(market_data.symbol, hours=168)
        if extremes["min"] > 0:
            current = market_data.current_price.price_eur
            distance_to_min = ((current - extremes["min"]) / extremes["min"]) * 100
            distance_to_max = ((extremes["max"] - current) / extremes["max"]) * 100
            
            if distance_to_min < 10:
                score += 1.5
                reasons.append("‚úÖ Proche du plus bas r√©cent")
            elif distance_to_max < 10:
                score -= 1
                reasons.append("‚ö†Ô∏è Proche du plus haut r√©cent")
        
        score = max(0, min(10, int(score)))
        
        # Recommandation
        if score >= 8:
            recommendation = "EXCELLENTE opportunit√© d'achat ! üéØ"
        elif score >= 7:
            recommendation = "Tr√®s bonne opportunit√© üíé"
        elif score >= 6:
            recommendation = "Opportunit√© correcte"
        elif score >= 4:
            recommendation = "Moment neutre ‚öñÔ∏è"
        else:
            recommendation = "Pas un bon moment ‚ùå"
        
        return OpportunityScore(
            score=score,
            reasons=reasons[:5],
            recommendation=recommendation
        )
